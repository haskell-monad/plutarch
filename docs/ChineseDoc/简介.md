> 注意：如果您发现任何错误/有任何本指南无法回答的相关问题，请不要犹豫，立即提出问题。我们的目标是为Plutarch用户提供高质量的文档！

# 概述

Plutarch是Haskell中的一个eDSL，用于为Cardano编写链上脚本。需要注意的是，Plutarch是一个[简单类型的lambda演算](https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus)(或STLC)。在Plutarch中编写脚本允许我们利用Haskell提供的语言特性，同时保留编译为紧凑的无类型Plutus Core(或UPLC，它是一种无类型的lambda演算)的能力。

当我们谈论"Plutarch脚本"时，我们指的是类型为`Term (s :: S) (a :: PType)`的值。`Term`是围绕更复杂类型的`newtype`包装器，`Plutarch`最终用户可以忽略其细节。`Term`是一个类型化的`lambda term`; 它可以被认为是表示一个计算，如果成功评估，将返回一个类型为`a`的值。

`Term s a` 声明的两个类型变量有特定的`kinds`(种类):

- `s :: S`类似于`ST s a`中的`s`。它以模仿可变状态的方式表示计算上下文，同时提供熟悉的函数式接口。\[[1](#references)]的第1节到第4节对它的工作原理进行了简单易懂的介绍。`s` 永远不会用具体值实例化；这只是一种类型级别的方法，可以确保计算上下文保持适当的封装(即不同状态的线程不进行交互)。有关Plutarch中使用的eDSL设计原则和其他eDSL设计原则的更深入介绍，请参见: \[[2](#references)].
- `a :: PType`是"Plutarch Type"的简写。我们在这些类型前面加上一个大写的"P, 例如"PInteger"、"PBool"等等。使用PType标记`Term`表示`Term`的返回值的类型。这样做可以让我们在Plutarch的简单类型系统和无类型UPLC之间架起一座桥梁。

请注意，我们不应将类型`PType`的`kind`(种类)视为携带值；它是可能产生值的计算的标记。例如，`PInteger`的定义很简单:

```hs
data PInteger s
```

也就是说，没有数据构造函数。 如果一个类型为`Term s PInteger`的值在上下文`s`中成功执行了计算，`computed`值将是一个整数。我们永远不会遇到像`y :: PInteger; y = 3`这样的值;它们根本不存在。虽然Plutarch的新读者可能需要一些时间才能将其融入他们的心智模型，但要牢记这一点至关重要。

> 为简洁起见，我们将说"类型为`Term s a`的值将评估为`(...)`"。这个短语将带有两个隐含的概念: 一个，`Term s a`表示在上下文`s`中执行的计算；二、评估`Term s a`并不能保证成功。

简而言之，在编写Plutarch脚本时，我们有几个任务:

- A.) 定义`Plutarch Types`(或`PType`s)。我们在这些类型前面加上一个大写的`P`，例如`PInteger`、`PMaybe a`、`PBool`等等。如前所述，这些构成了Plutarch `Term` 的"tags"，表示编译和评估Plutarch脚本的结果的类型。
- B.) 与`Plutarch Terms`一起工作，它们是`Term (s :: S) (a :: PType)`类型的值。这些是"Plutarch"脚本本身，我们从中构建更复杂的脚本，然后在链上编译和执行它们。
- C.) 在`Plutarch Terms`之间编写Haskell级别的函数(即，类型如:`Term s a -> Term s b`)。这样做可以让我们利用Haskell的语言特性和生态系统。
- D.) 有效地将函数从`(C.)`转换为`Plutarch`级别的函数，它们的类型为`Term s (a :--> b)`。我们可以使用`plam`将函数从`(C.)`直接转换为最简单的Plutarch级别函数。其他Plutarch实用程序提供了优化机会。
- E.) 编译并执行`(D.)`中的函数，以"UPLC"为目标进行链上使用。

作为预览，Plutarch在Haskell和UPLC之间提供的桥梁看起来像这样:

    ------------------------------------------------------
    |                  *Haskell World*                   |
    ------------------------------------------------------
    | 类型为 `Bool`、`Integer`、`Maybe a` 的值             |
    ------------------------------------------------------
                               ^                     |
     (functions like `plift`)--|                     |--(functions like `pconstant`)
                               |                     |
                               |                     v         (`pcon`)
    -------------------------------------------------------    |                     -------------------------------------------------------
    |                  *Plutarch Term World*              | <----------------------- |                  *Plutarch Type World*              |
    -------------------------------------------------------                          -------------------------------------------------------
    | STLC terms; constants like `Term s PInteger` and    | -----------------------> | 像`PInteger`、`PMaybe a` 这样的类型                   |
    | lambdas like `Term s (PInteger :--> PBool)`         |        |                 |                                                     |
    -------------------------------------------------------        (`pmatch`)       -------------------------------------------------------
                                  |
                                  |
                                  |--(`compile`)
                                  |
                                  |
                                  v
    -------------------------------------------------------
    |                    *UPLC World*                     |
    -------------------------------------------------------
    | 无类型的lambda演算terms。 `Data` 类型的值               |
    |                                                     |
    -------------------------------------------------------

此外，您可能会注意到 Plutarch 中的两大类函数: terms之间的"Haskell级别"的函数，以及作为lambda terms的"Plutarch级别"的函数。例如，按照惯例，我们将在Haskell级别的函数前面加上`h`，在Plutarch级别的lambdas前面加上`p`.

```hs
-- 此示例在此处作为预览列出; 下面将详细介绍不熟悉的部分

-- A Plutarch-level lambda term
pf :: Term s (a :--> b :--> c)

-- Rcovering a Haskell level function from a Plutarch level function
hf :: Term s a -> Term s b -> Term s c
hf x y = pf # x # y
```

请注意，`pf`实际上只是一个Plutarch`Term`，不应该被特别对待。它不会涵盖编写生产就绪脚本所需的所有技术。它也不会涵盖超出最低限度的Plutarch和UPLC之间的桥梁.尽管如此，它应该提供足够的背景知识，让读者为进一步的学习做好准备。

本文档的其余部分从高层次上介绍了Haskell和Plutarch之间的桥梁。

小节:-

- [Untyped Plutus Core (UPLC)](./Introduction/Untyped%20Plutus%20Core.md)
- [Plutarch Types](./Introduction/Plutarch%20Types.md)
- [Plutarch `Term`s](./Introduction/Plutarch%20Terms.md)
  - [Plutarch Constant `Term`s](./Introduction/Plutarch%20Terms/Plutarch%20Constants.md)
    - [Static building of constant `Term`s with `pconstant`](./Introduction/Plutarch%20Terms/Plutarch%20Constants.md#static-building-of-constant-terms-with-pconstant)
    - [Dynamic building of constant `Term`s with `pcon`](./Introduction/Plutarch%20Terms/Plutarch%20Constants.md#dynamic-building-of-constant-terms-with-pcon)
    - [Overloaded literals](./Introduction/Plutarch%20Terms/Plutarch%20Constants.md#overloaded-literals)
    - [Helper functions](./Introduction/Plutarch%20Terms/Plutarch%20Constants.md#helper-functions)
  - [Lambdas; Plutarch-level Function `Term`s.](./Introduction/Plutarch%20Terms/Plutarch%20Lambdas.md#lambdas-plutarch-level-function-terms)
    - [Function Application](./Introduction/Plutarch%20Terms/Plutarch%20Lambdas.md#function-application)
- [Pattern matching constant `Term`s with `pmatch`.](./Introduction/Pattern%20matching.md)
- [Strictness and Laziness; Delayed Terms and Forcing](./Introduction/Delay%20and%20Force.md)

# References

- \[1][惰性功能状态线程, by John Launchbury and Simon L Peyton Jones](https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf)
- \[2][未嵌入的领域特定语言, by Robert Atkey, Sam Lindley, and Jeremy Yallop](https://bentnib.org/unembedding.pdf)
- \[3][Matt Parson: Haskell中的基本类型级编程](https://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html)
